package org.softwood.actor

import java.util.concurrent.StructuredTaskScope

/**
 * Actor System that manages multiple actors using a StructuredTaskScope
 * Updated for Java 25 â€” StructuredTaskScope is now a sealed interface,
 * instantiated via factory methods rather than constructors.
 *
 * Requires:
 *   javac --enable-preview --release 25
 *   java  --enable-preview
 */


class ActorSystemPendingStructuredConcurrency implements AutoCloseable {
    private final String name
    private final List<ScopedValueActor> actors = [].asSynchronized()

    ActorSystemPendingStructuredConcurrency(String name = "ActorSystem") {
        this.name = name
        println "ActorSystem '$name' created"
    }

    /**
     * Register an actor with this system
     */
    def <T> ScopedValueActor<T> registerActor(ScopedValueActor<T> actor) {
        actors << actor
        return actor
    }

    /**
     * Create and register a new actor
     */
    def <T> ScopedValueActor<T> createActor(
            String name,
            ScopedValueActor.MessageHandler<T> handler,
            int mailboxSize = 1000
    ) {
        def actor = new ScopedValueActor<T>(name, handler, mailboxSize)
        actors << actor
        return actor
    }

    /**
     * Run an operation across all actors concurrently in a structured scope.
     * This demonstrates the Java 25 style StructuredTaskScope.open().
     */
    void superviseActors() throws InterruptedException {
        if (actors.isEmpty()) {
            println "No actors to supervise."
            return
        }

        // Open a new structured scope (default joiner: cancel on failure)
        try (var scope = StructuredTaskScope.<Void, Void>open()) {
            actors.each { actor ->
                scope.fork {
                    try {
                        actor.runLoop()  // Example long-running method
                        return null
                    } catch (Exception e) {
                        println "Actor '${actor.name}' failed: ${e.message}"
                        throw e
                    }
                }
            }

            // Wait for all subtasks to finish or any failure
            try {
                scope.join()
            } catch (StructuredTaskScope.FailedException fe) {
                println "ActorSystem '$name': failure detected, cancelling others"
            }
        }

        println "All actors completed or cancelled in ActorSystem '$name'"
    }

    /**
     * Shutdown all actors in the system.
     */
    void shutdown() {
        println "Shutting down ActorSystem '$name' with ${actors.size()} actors"

        actors.each { it.stop() }

        actors.each {
            try {
                it.stopAndWait()
            } catch (Exception e) {
                println "Error stopping actor: ${e.message}"
            }
        }

        println "ActorSystem '$name' shutdown complete"
    }

    @Override
    void close() {
        shutdown()
    }

    int getActorCount() {
        actors.size()
    }

    List<ScopedValueActor> getActors() {
        actors.collect()  // Return a copy
    }
}
