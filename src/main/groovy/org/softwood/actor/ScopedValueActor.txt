package org.softwood.actor

import java.time.Duration
import java.util.concurrent.*
import java.util.concurrent.atomic.AtomicLong
import groovy.transform.CompileStatic

/**
 * Java 25 Structured Concurrency version of ScopedValueActor
 * Uses StructuredTaskScope.open() (1 generic param) and resultNow() instead of get().
 */

/*
@CompileStatic
class ScopedValueActor<M> implements AutoCloseable {

    private static final ScopedValue<ActorContext> ACTOR_CONTEXT = ScopedValue.newInstance()

    private final String name
    private final BlockingQueue<Message<M>> mailbox
    private final MessageHandler<M> handler
    private volatile boolean running = true
    private final AtomicLong messageCount = new AtomicLong(0)
    private final Map<String, Object> state = [:].asSynchronized()

    private StructuredTaskScope<Object> scope
    private StructuredTaskScope.Subtask<Object> messageLoopTask

    // ----------------------------------------------------------------
    static class Message<M> {
        final M payload
        final String sender
        final long timestamp
        final CompletableFuture<Object> replyTo
        Message(M payload, String sender = "anonymous", CompletableFuture<Object> replyTo = null) {
            this.payload = payload
            this.sender = sender
            this.timestamp = System.currentTimeMillis()
            this.replyTo = replyTo
        }
    }

    static class ActorContext {
        final String actorName
        final Map<String, Object> state
        final long messageNumber
        ActorContext(String actorName, Map<String, Object> state, long messageNumber) {
            this.actorName = actorName
            this.state = state
            this.messageNumber = messageNumber
        }
        def get(String key) { state.get(key) }
        void set(String key, Object value) { state.put(key, value) }
        boolean has(String key) { state.containsKey(key) }
        void remove(String key) { state.remove(key) }
    }

    @FunctionalInterface
    interface MessageHandler<M> {
        Object handle(M message, ActorContext context)
    }

    ScopedValueActor(String name, MessageHandler<M> handler, int mailboxSize = 1000) {
        this.name = name
        this.handler = handler
        this.mailbox = new LinkedBlockingQueue<>(mailboxSize)
        startMessageLoop()
    }

    private void startMessageLoop() {
        scope = StructuredTaskScope.open()   // ✅ returns StructuredTaskScope<Object>

        messageLoopTask = scope.fork(() -> {
            println "Actor '$name' started in thread: ${Thread.currentThread()}"
            try {
                while (running || !mailbox.isEmpty()) {
                    Message<M> msg = mailbox.poll(100, TimeUnit.MILLISECONDS)
                    if (msg != null) processMessage(msg)
                }
                println "Actor '$name' stopped"
            } catch (InterruptedException e) {
                println "Actor '$name' interrupted"
                Thread.currentThread().interrupt()
            } catch (Throwable t) {
                println "Actor '$name' failed: ${t.message}"
                throw t
            }
            return "Actor $name completed"
        })
    }

    private void processMessage(Message<M> message) {
        long msgNum = messageCount.incrementAndGet()
        ActorContext context = new ActorContext(name, state, msgNum)
        try {
            Object result = ScopedValue.where(ACTOR_CONTEXT, context)
                    .call(() -> handler.handle(message.payload, context))
            if (message.replyTo)
                message.replyTo.complete(result)
        } catch (Throwable t) {
            println "Actor '$name' handler error: ${t.message}"
            if (message.replyTo)
                message.replyTo.completeExceptionally(t)
            throw t
        }
    }

    void send(M message, String sender = "anonymous") {
        if (!running) throw new IllegalStateException("Actor '$name' not running")
        if (!mailbox.offer(new Message<M>(message, sender)))
            throw new IllegalStateException("Actor '$name' mailbox full")
    }

    CompletableFuture<Object> ask(M message, String sender = "anonymous") {
        if (!running) throw new IllegalStateException("Actor '$name' not running")
        def reply = new CompletableFuture<Object>()
        if (!mailbox.offer(new Message<M>(message, sender, reply)))
            reply.completeExceptionally(new IllegalStateException("Actor '$name' mailbox full"))
        return reply
    }

    Object askSync(M message, String sender = "anonymous", Duration timeout = Duration.ofSeconds(5)) {
        ask(message, sender).get(timeout.toMillis(), TimeUnit.MILLISECONDS)
    }

    static ActorContext getCurrentContext() {
        if (!ACTOR_CONTEXT.isBound()) throw new IllegalStateException("Not in actor context")
        ACTOR_CONTEXT.get()
    }
    static boolean isInActorContext() { ACTOR_CONTEXT.isBound() }

    int getMailboxSize() { mailbox.size() }
    long getMessageCount() { messageCount.get() }

    void stop() { running = false }

    void stopAndWait(Duration timeout = Duration.ofSeconds(10)) {
        running = false
        try {
            scope.join()
            println "Actor '$name' joined successfully"
        } catch (StructuredTaskScope.FailedException fe) {
            println "Actor '$name' failed during join: ${fe.cause?.message}"
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt()
            println "Actor '$name' interrupted during shutdown"
        } finally {
            scope.close()
        }
    }

    String getResult() {
        try {
            // ✅ Subtask.get() removed; use resultNow()
            return messageLoopTask.resultNow()?.toString() ?: "Actor $name completed"
        } catch (Exception e) {
            return "Actor $name failed: ${e.message}"
        }
    }

    @Override void close() { stopAndWait() }

    @Override String toString() {
        "Actor[$name](messages: ${messageCount.get()}, mailbox: ${mailbox.size()})"
    }
}
*/

